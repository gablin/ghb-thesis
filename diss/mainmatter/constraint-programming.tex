% Copyright (c) 2017, Gabriel Hjort Blindell <ghb@kth.se>
%
% This work is licensed under a Creative Commons 4.0 International License (see
% LICENSE file or visit <http://creativecommons.org/licenses/by/4.0/> for a copy
% of the license).

\chapter{Constraint Programming}
\labelChapter{constraint-programming}

This chapter describes \glsdesc{CP}, which is the method used in this
dissertation for modeling and solving the problems described in
\refChapter{introduction}.
%
\refSection{cp-overview} gives a brief overview (for a comprehensive overview of
\gls{CP}, see \cite{RossiEtAl:2006}).
%
\refSection{cp-modeling} describes how to describe problems as a \gls{constraint
  model}, and \refSection{cp-solving} describes the techniques applied in
solving these \glsplshort{constraint model}.



\section{Overview}
\labelSection{cp-overview}

As already mentioned, \glsdesc{CP} is a method for solving computationally hard
problems.
%
These problems are typically optimization problems, but the method can also be
applied to solve satisfaction problems.
%
In terms of modeling, \gls{CP} offers a higher level of abstraction than similar
methods such as \gls{IP} and \gls{SAT}~\cite{BiereEtAl:2009}.
%
For example, \gls{CP} provides dedicated constraints for capturing many
recurring problem structures that must be decomposed and reformulated in
\gls{IP} and \gls{SAT}~models.
%
This also makes \gls{CP} particularly suited for solving problems that appear in
\gls{instruction selection}, \gls{global code motion}, and \gls{block ordering}.



\section{Modeling}
\labelSection{cp-modeling}

To solve a problem using \gls{CP}, it must first be formulated as a
\gls{constraint model}~\cite{Smith:2006}.
%
A \gls!{constraint model} consists of two elements:%
%
\begin{inlinelist}[itemjoin={, }, itemjoin*={, and}]
  \item a set of \glspl{variable}
  \item a set of \glspl{constraint}
\end{inlinelist}.
%
\Glspl!{variable} represent problem decisions and take their values from a
finite \gls{domain}.
%
The \gls!{domain} of a variable~$x$, denoted $\mDomain(\mVar{x})$, is typically
is a set of integers, but it can also consist of real numbers and complex
structures such as string, sets, and \glspl{graph}~\cite{Gervet:2006}.
%
\Glspl!{constraint} express relations between \glspl{variable} and forbid
assignments that are illegal in the problem.
%
Formally, we say that a \gls{constraint}~$C$ applied on a set of
\glspl{variable} returns a subset of the Cartesian product of the
\glspl{variable}' \glspl{domain}, i.e.\ \mbox{$C(\mVar{x}_1, \ldots, \mVar{x}_k)
  \subseteq \mDomain(\mVar{x}_1) \times \ldots \times \mDomain(\mVar{x}_k)$}.
%
A tuple $\mTuple{d_1, \ldots, d_k} \in C(\mVar{x}_1, \ldots, \mVar{x}_k)$ is
called a \gls!{solution}[ to $C$], and an assignment to all \glspl{variable}
that fulfills all \glspl{constraint} in a \gls{constraint model}~$M$ is called a
\gls!{solution}[ to $M$].
%
An example is shown in \refFigure{cp-example}.

\begin{figure}
  \centering%
  \figureFont\figureFontSize%
  \mbox{}%
  \hfill\hfill%
  \subcaptionbox{Constraint model\labelFigure{cp-example-model}}%
                {%
                  \begin{tabular}{lc}
                    \toprule
                    \multicolumn{1}{c}{\tabhead Variables}
                      & \tabhead Constraints\\
                    \midrule
                      $\mVar{x} \in \mSet{1, 2}$ & $\mVar{x} \neq \mVar{y}$\\
                      $\mVar{y} \in \mSet{1, 2}$ & $\mVar{x} \neq \mVar{z}$\\
                      $\mVar{z} \in \mSet{1, 2, 3, 4}$
                        & $\mVar{y} \neq \mVar{z}$\\
                    \bottomrule
                  \end{tabular}%
                }%
  \hfill%
  \subcaptionbox{Solutions\labelFigure{cp-example-solutions}}%
                [21mm]%
                {%
                  $\begin{array}{c@{\:}c@{\:}c@{\:}c@{\:}c}
                       & \mVar{x}\phantom{,}
                       & \mVar{y}\phantom{,}
                       & \mVar{z}
                       & \\
                     \langle & 1, & 2, & 3 & \rangle \\
                     \langle & 2, & 1, & 3 & \rangle \\
                     \langle & 1, & 2, & 4 & \rangle \\
                     \langle & 2, & 1, & 4 & \rangle \\
                   \end{array}$%
                }%
  \hfill\hfill%
  \mbox{}

  \caption[Example of a constraint model]%
          {%
            Example of a constraint model, corresponding to a problem where
            three variables must be assigned values which are different from one
            another%
          }
  \labelFigure{cp-example}
\end{figure}



\subsubsection{Global Constraints}

If a \gls!{binary.c}[ \gls{constraint}] is a \gls{constraint} involving two
\glspl{variable}, then a \gls!{global.c}[ \gls{constraint}] is a
\gls{constraint} involving three or more
\glspl{variable}~\cite{VanHoeveKatriel:2006}.
%
\Gls{global.c} \glspl{constraint} capture recurring problem structures and
improve solving compared to relations modeled using multiple \gls{binary.c}
\glspl{constraint}.

Arguably, the most well-known \gls{global.c} \gls{constraint} is the
\gls!{distinct constraint}.
%
Typically referred to as $\mDistinct$ or $\mAllDiff$, the \gls{constraint}
enforces all \glspl{variable} in a given set to take distinct values.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Distinct Constraint]%
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a set of \glspl{variable}.
  %
  Then
  %
  \begin{displaymath}
    \mDistinct(\mVar{x}_1, \ldots, \mVar{x}_k)
    =
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {\forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                 \forall_{\! i \neq j} \: d_i \neq d_j}.
  \end{displaymath}%
\end{definition}

Hence the \glspl{constraint} in \refFigure{cp-example} can be replaced by
$\mDistinct(\mVar{x}, \mVar{y}, \mVar{z})$.

In \refChapter{existing-isel-techniques-and-reps} we saw another \gls{global.c}
\gls{constraint} -- the \gls{global cardinality constraint} -- and how it can be
used to model the \gls{pattern selection} problem (see
\refEquation{pattern-selection-using-gcc}).
%
For completeness, we provide the formal definition of the \gls{constraint}.
%
\begin{definition}[Global Cardinality Constraint]%
  Let $v$ be a value, and let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k, \mVar{y}$}
  be a set of \glspl{variable}.
  %
  Then
  %
  \begin{displaymath}
    \mGCC(v, \mVar{x}_1, \ldots, \mVar{x}_k, \mVar{y})
    =
    \mSetBuilder*{\mTuple{d_1, \ldots, d_k, e}}%
                 {
                   \begin{array}{l}
                     \forall_i \: d_i \in \mDomain(\mVar{x}_i),
                     e \in \mDomain(\mVar{y}), \\
                     e = |\mSetBuilder{d_i}{\forall_i \: d_i = v}|
                   \end{array}
                 }.
  \end{displaymath}%
  \labelDefinition{gcc}%
\end{definition}

Another relevant example is the \gls!{circuit constraint}, typically referred to
as $\mCircuit$ or $\mCycle$, which enforces that the \glspl{variable}
representing adjacency forms a cycle.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Circuit Constraint]
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a set of \glspl{variable} with
  \glspl{domain} \mbox{$\mDomain(\mVar{x}_i) \subseteq \mSet{1, \ldots, k}$} for
  \mbox{$i = 1, \ldots, k$}.
  %
  Let also a permutation~\mbox{$P = d_1, \ldots, d_k$} of \gls{domain} values be
  considered \emph{cyclic} if the set $S_P$, defined as
  %
  \begin{displaymath}
    \begin{array}{c}
      1 \in S_P,
      i \in S_P \mImp d_i \in S_P,
    \end{array}
  \end{displaymath}
  %
  has $k$ elements.
  %
  Then
  %
  \begin{displaymath}
    \mCircuit(\mVar{x}_1, \ldots, \mVar{x}_k)
    =
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\! i} \: d_i \in \mDomain(\mVar{x}_i),
                  \text{$d_1, \ldots, d_k$ is cyclic}
                }.
  \end{displaymath}
\end{definition}

As will be seen in \refChapter{modeling-block-ordering}, $\mCircuit$ can be used
to model \gls{block ordering}.

The last \gls{global.c} \gls{constraint} relevant for this dissertation is the
\gls{table constraint}, which constrains a vector of \glspl{variable} such that
the values appear as a row in a given matrix.
%
By encoding legal \gls{variable} assignments into the matrix, any relation can
be expressed using a \gls{table constraint}.
%
Formally, the \gls{constraint} is defined as follows.
%
\begin{definition}[Table Constraint]
  Let \mbox{$\mVar{x}_1, \ldots, \mVar{x}_k$} be a set of \glspl{variable}, and
  let $T$ be an \mbox{$m \times k$} matrix, where \mbox{$m \in \mathbb{N}$}.
  %
  Then
  %
  \begin{displaymath}
    \mTable(\mVar{x}_1, \ldots, \mVar{x}_k, T)
    =
    \mSetBuilder{\langle d_1, \ldots, d_k \rangle}%
                {
                  \forall_{\!i } \: d_i \in \mDomain(\mVar{x}_i),
                  d_1, \ldots, d_k \in T
                }.
  \end{displaymath}
\end{definition}

As will be seen in \refChapter{solving-techniques}, $\mTable$ can be used to
refining the modeling of cost.



\subsubsection{Optimization}

In \gls{CP}, an optimization problem is modeled by maximizing or minimizing a
\gls{variable}~$\mVar{c}$ whose value is constrained according to the objective
function.
%
For example, if $\mVar{x}_m$ is Boolean \gls{variable} representing whether
match~$m$ is selected and $c_m$ denotes the cost of selecting $m$, then a
\gls{CP} idiom for modeling \gls{optimal.ps} \gls{pattern selection} is
%
\begin{equation}
  \begin{array}{rl}
      \text{minimize} & \mVar{c} \\
    \text{subject to} & \mVar{c} = \displaystyle\sum_m c_m \mVar{x}_m
  \end{array}
  \labelEquation{pattern-selection-in-cp}
\end{equation}
%
In this context, $\mVar{c}$ is called a \gls!{cost variable}.


\section{Solving}
\labelSection{cp-solving}

A \gls!{constraint solver} (or just \gls!{solver}) finds \glspl{solution} to a
\gls{constraint model} by interleaving \gls{propagation} and \gls{search}.
%
\Gls!{propagation} removes \gls{domain} values that are known not to appear in
any \gls{solution}, and \gls!{search} attempts several alternatives when
\gls{propagation} is not enough to find a \gls{solution}.

In practice, however, this alone is not enough for many problem instances
because the \gls{search space} is simply too large.
%
The \gls{search space} can be reduced by extending the \gls{constraint model}
with \gls{implied.c} and \gls{dominance breaking.c} \glspl{constraint} and by
performing \gls{presolving}.
%
An \gls!{implied.c}[ \gls{constraint}] is a \gls{constraint} that strengthens
propagation without removing any \glspl{solution}.
%
A \gls!{dominance breaking.c}[ \gls{constraint}] is a \gls{constraint} that
removes \glspl{solution} known to be dominated by another \gls{solution}.
%
\Gls!{presolving} applies problem-specific techniques before solving that shrink
the \gls{variable} \glspl{domain}.



\subsubsection{Propagation}

\todo{write}



\subsubsection{Search}

\todo{write}



\subsubsection{Implied and Dominance Breaking Constraints}

\todo{write}



\subsubsection{Presolving}

\todo{write}
